const c=Symbol("is-state-variable"),u=new WeakMap;function d(h){if(h!=null&&h[c]&&(h=h.get()),u.has(h))return u.get(h);const t={thing:h},i=new r(t,"thing").proxy;return h&&typeof h=="object"&&u.set(h,i),i}class r extends EventTarget{static map=new WeakMap;static parentMap=new WeakMap;static proxyActions=["apply","construct","defineProperty","deleteProperty","get","getOwnPropertyDescriptor","getPrototypeOf","has","isExtensible","ownKeys","preventExtensions","set","setPrototypeOf"];object;key;callback;specials={valueOf:()=>this.value,toString:()=>this.value.toString(),toJSON:()=>this.isObject?this.value:JSON.stringify(this.value),get:()=>this.value,set:t=>{t!=null&&t[c]&&(t=t.get()),this.change(()=>this.object[this.key]=t)},is:t=>t?.[c]?this.value==t.get():this.value==t,delete:()=>this.change(()=>delete this.object[this.key]),typeof:()=>typeof this.value,addEventListener:(...t)=>this.addEventListener(...t),removeEventListener:(...t)=>this.removeEventListener(...t),dispatchEvent:(...t)=>this.dispatchEvent(...t)};constructor(t,e,i=null){r.map.has(t)||r.map.set(t,{});const s=r.map.get(t);if(s[e])return s[e];super();Object.assign(this,{object:t,key:e,callback:i}),s[e]=this,this.initialize(),this.changeValue(this.value)}get value(){return this.object[this.key]}get isObject(){return typeof this.value=="object"&&this.value!=null}get isArray(){return Array.isArray(this.value)}change(t){const e=this.value;t();const{value:i,key:s}=this;this.changeValue(i,e),this.dispatchValueChange(i,e),r.parentMap.get(this.object)?.forEach(a=>a.dispatchPropertyChange(s))}dispatchValueChange(t,e){if(t===e)return;const i={oldValue:e,value:t};this.dispatchEvent(new CustomEvent("valuechange",{detail:i})),this.dispatchEvent(new CustomEvent("change",{detail:i}))}dispatchPropertyChange(t){const e=t==null?{unknown:!0}:{property:t};this.dispatchEvent(new CustomEvent("propertychange",{detail:e})),this.dispatchEvent(new CustomEvent("change",{detail:e}))}changeValue(t,e){r.parentMap.get(e)?.delete(this),this.isObject&&(typeof t!="object"||t==null||(r.parentMap.has(t)||r.parentMap.set(t,new Set),r.parentMap.get(t).add(this)))}isPropertyReference(t){return this.isObject?this.isArray?typeof t=="symbol"?!1:!!(Number.isInteger(+t)&&t>=0):!0:!1}initialize(){const t=this.callback?function(){}:{},e={};e.get=(i,s)=>this.get(s),e.set=(i,s,a)=>(this.isPropertyReference(s)&&this.proxy[s].set(a),!0),e.deleteProperty=(i,s)=>{if(!!this.isPropertyReference(s))return this.proxy[s].delete(),!0},e.apply=(i,s,...a)=>this.callback.apply(s,...a);for(const i of r.proxyActions)e[i]??=(s,...a)=>Reflect[i](this.value,...a);this.proxy=new Proxy(t,e)}get(t){if(t==c)return!0;if(!this.isObject&&t==Symbol.toPrimitive)return()=>this.value;const e=this.specials[t];if((!this.isObject||this.isArray)&&e)return e;const i=this.getFlattenedValue(t);if(!this.isPropertyReference(t))return i;const s=this.value;return new r(s,t,e).proxy}getFlattenedValue(t){const e=this.value[t];return typeof e!="function"?e:this.isArray?(...i)=>this.callArrayMethod(this.value,t,...i):e.bind(this.value)}callArrayMethod(t,e,...i){const s=[...t],a=t,l=t[e](...i);if(!(s.length!=a.length||a.some((n,p)=>n!==s[p])))return l;const f=Math.max(s.length,a.length),o=[];for(let n=0;n<f;n++)a[n]!==s[n]&&o.push(n);for(const n of o)this.changeValue(a[n],s[n]);const g=r.map.get(t);for(const n of o)g?.[n]?.dispatchValueChange(a[n],s[n]);return r.parentMap.get(t)?.forEach(n=>n.dispatchPropertyChange()),l}}export{d as default};
